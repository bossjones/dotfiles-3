#!/usr/bin/env python

import fnmatch
import logging
import optparse
import os
import pyinotify
import subprocess
import sys
import time

class Error(Exception): pass

class WatchRestart(object):

    def __init__(self, command, watch, ignore=None, verbose=False):
        self.command = command
        self.process = None
        self.ignore = ignore or []
        self.watch = watch
        self.verbose = verbose

        self.events = pyinotify.IN_CLOSE_WRITE \
                    | pyinotify.IN_CREATE      \
                    | pyinotify.IN_DELETE      \
                    | pyinotify.IN_MODIFY

    def setup(self):
        self.manager = pyinotify.WatchManager()
        self.notifier = pyinotify.Notifier(self.manager, default_proc_fun=lambda x: None if not self.verbose else None)
        exclude = pyinotify.ExcludeFilter(self.ignore) if self.ignore else None
        self.manager.add_watch(
            self.watch,
            self.events,
            rec=True,
            exclude_filter=exclude,
        )
        self.run()
        self.last_restart = time.time()

    def loop(self):
        self.notifier.loop(callback=self.restart)

    def run(self):
        logging.debug('Starting command %s' % self.command)
        try:
            self.process = subprocess.Popen(self.command, shell=True)
        except OSError, error:
            raise Error('Unable to run command: %s' % error)
        time.sleep(1)
        if self.process.poll():
            raise Error('Process failed to start.')

    def kill(self):
        try:
            if self.process:
                logging.debug('Killing process %s' % self.process.pid)
                self.process.kill()
                self.process.wait()
        except OSError:
            pass

    def restart(self, *args, **kwargs):
        current_time = time.time()
        if (current_time - self.last_restart) > 2:
            self.last_restart = current_time
            self.kill()
            self.run()
        else:
            logging.debug('Ignoring because time diff not meet.')

def exit(text='', code=1):
    text = unicode(text)
    if code > 0:
        if text:
            print >> sys.stderr, text
        sys.exit(code)
    else:
        if text:
            print text
        sys.exit(0)

if __name__ == '__main__':
    parser = optparse.OptionParser()
    parser.usage = '%prog [options] command'
    parser.add_option(
        '--ignore',
        default='',
        dest='ignore',
        help='ignore configuration file',
        metavar='PATH',
    )
    parser.add_option(
        '--path',
        default='.',
        dest='path',
        help='directory to watch for file events',
        metavar='PATH',
    )
    parser.add_option(
        '--regex',
        action='store_true',
        dest='regex',
        help='use regex instead of glob',
    )
    parser.add_option(
        '-v',
        '--verbose',
        action='store_true',
        dest='verbose',
        help='show debug information',
    )
    options, args = parser.parse_args()

    if options.verbose:
        logging.basicConfig(level=logging.DEBUG)

    if os.path.isfile(options.path):
        options.path = os.path.dirname(options.path)
        print >> sys.stderr, 'Converting path to directory: %s' % options.path

    if options.ignore:
        if not os.path.isfile(options.ignore):
            exit('Ignore file not found.')
    else:
        options.ignore = os.path.join(os.getcwd(), '.wrignore')

    ignore = []
    if os.path.isfile(options.ignore):
        with open(options.ignore) as f:
            ignore = f.readlines()
            ignore = [rule.strip() for rule in ignore]
    if ignore and not options.regex:
        ignore = [fnmatch.translate(rule) for rule in ignore]

    command = ' '.join(args)

    if not command:
        exit('Command is required.')

    watch = [options.path]

    try:
        wr = WatchRestart(command=command, ignore=ignore, watch=watch, verbose=options.verbose)
        wr.setup()
        wr.loop()
    except Error, error:
        exit(error)
