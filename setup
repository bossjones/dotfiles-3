#!/usr/bin/env python
# encoding: utf-8

import Queue
import httplib
import logging
import os
import pipes
import subprocess
import sys
import threading
import urlparse


class Error(Exception):
    pass


class File(object):

    def __init__(self, name, url=None, path=None, mode=0600,
                 directory_mode=0700, extract=True):
        self.name = name
        self.mode = mode
        self.directory_mode = 0700
        self.path = path or os.path.expanduser('~/%s' % self.name)
        self.directory = os.path.dirname(self.path)
        self.extract = extract
        if url is None:
            url = 'https://raw.github.com/silas/config/master/src/%s' % name
        self.set_url(url)

    def __str__(self):
        return self.name

    def __repr__(self):
        return 'file %r' % str(self)

    @staticmethod
    def link(src_path, dst_path):
        src = os.path.expanduser(src)
        dst = os.path.expanduser(dst)
        if not os.path.exists(dst):
            os.symlink(src, dst)

    @staticmethod
    def write(path, data, mode=0600):
        path = os.path.expanduser(path)
        with open(path, 'w+', mode) as f:
            f.write(data)

    def set_url(self, value):
        self.url = urlparse.urlparse(value)
        if not hasattr(self, 'original_url'):
            self.original_url = self.url

    def fetch(self):
        while True:
            if self.url.scheme == 'https':
                c = httplib.HTTPSConnection(self.url.netloc)
            else:
                c = httplib.HTTPConnection(self.url.netloc)
            c.request('GET', self.url.path)
            res = c.getresponse()
            if res.status in (301, 302) and 'Location' in res.msg:
                self.set_url(res.msg['Location'])
                continue
            elif res.status < 200 or res.status >= 300:
                raise Error('failed to get %s (%s)' % (self.url, res.status))
            return res.read()

    def run(self):
        data = self.fetch()
        if not os.path.isdir(self.directory):
            os.makedirs(self.directory, self.directory_mode)
        if self.extract and self.original_url.path.endswith('.tar.gz'):
            if not os.path.isdir(self.path):
                os.makedirs(self.path, self.directory_mode)
            p = subprocess.Popen(
                'tar -xz --strip-components=1 -C %s' % pipes.quote(self.path),
                shell=True,
                stdin=subprocess.PIPE,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
            )
            out, _ = p.communicate(data)
            if p.returncode != 0:
                raise Error('failed to extract: %s' % out)
        else:
            self.write(self.path, data, self.mode)


class VimBundle(File):

    def __init__(self, name):
        url = 'https://github.com/%s/archive/master.tar.gz' % name
        name = name.split('/')[-1]
        if name.startswith('vim-'):
            name = name[4:]
        if name.endswith('.vim'):
            name = name[:-4]
        name = '.vim/bundle/%s' % name
        super(VimBundle, self).__init__(name, url)


class Shell(object):

    def __init__(self, command, codes=None):
        self.command = command
        self.codes = codes or [0]

    def __str__(self):
        if len(self.command) > 20:
            return '%s' % self.command[:20].strip()
        return self.command

    def __repr__(self):
        return 'shell %r' % str(self)

    def run(self):
        p = subprocess.Popen(
            self.command,
            shell=True,
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
        )
        out, _ = p.communicate()
        if p.returncode not in self.codes:
            raise Error(out)


class Platform(object):

    def __init__(self, pool):
        self.pool = pool

    def __str__(self):
        return sys.platform

    def __repr__(self):
        return 'platform %r' % str(self)

    def darwin(self):
        File.link('/usr/local/go/misc/vim', '~/.vim/bundle/golang')
        File.write('~/.bash_profile', '. ~/.bashrc')

    def run(self):
        getattr(self, sys.platform, lambda: None)()


class Pool(object):

    def __init__(self):
        self.q = Queue.Queue()
        self.tasks = []

    def add(self, obj):
        self.tasks.append(obj)

    def run(self):
        while True:
            try:
                task = self.q.get()
                logging.info('running %r', task)
                task.run()
            except Exception as e:
                logging.error('error %r: %s', task, e.message)
            finally:
                self.q.task_done()

    def start(self, num=5):
        for _ in xrange(num):
            t = threading.Thread(target=self.run)
            t.daemon = True
            t.start()

        for d in self.tasks:
            self.q.put(d)

        return self

    def join(self):
        self.q.join()
        return self


def main():
    logging.basicConfig(format='%(asctime)s - %(levelname)s - %(message)s',
                        level=logging.INFO)

    p = Pool()
    p.add(Platform(p))
    p.add(File('.bashrc'))
    p.add(File('.gdbinit'))
    p.add(File('.gemrc'))
    p.add(File('.gitconfig'))
    p.add(File('.hushlogin'))
    p.add(File('.screen/rock'))
    p.add(File('.screenrc'))
    p.add(File('.ssh/config'))
    p.add(File('.vimrc'))
    p.add(File('.vim/autoload/pathogen.vim', 'https://raw.github.com/tpope/vim-pathogen/master/autoload/pathogen.vim'))
    p.add(VimBundle('Shougo/neocomplcache.vim'))
    p.add(VimBundle('scrooloose/syntastic'))
    p.add(VimBundle('tpope/vim-endwise'))
    p.add(VimBundle('tpope/vim-markdown'))
    p.start().join()


if __name__ == '__main__':
    main()
